\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{array}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{float}

\usepackage[scaled]{helvet}
\renewcommand{\familydefault}{\sfdefault}

\usepackage[a4paper, top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{setspace}
\setstretch{1.5}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt}

\usepackage{microtype}
\sloppy
\hyphenpenalty=1000
\tolerance=3000

\renewcommand{\footnotesize}{\fontsize{10}{12}\selectfont}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\usepackage{titlesec}
\titleformat{\section}{\normalfont\fontsize{12}{14}\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\fontsize{12}{14}\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\fontsize{12}{14}\bfseries}{\thesubsubsection}{1em}{}

\usepackage[
  colorlinks=true,
  linkcolor=black,
  citecolor=blue,
  filecolor=black,
  urlcolor=blue
]{hyperref}
\usepackage[capitalise,nameinlink]{cleveref}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[C]{\thepage}

\usepackage[backend=biber, style=apa]{biblatex}
\addbibresource{references.bib}

\usepackage{titling}

\usepackage{acronym}
\usepackage[german=quotes]{csquotes}

\usepackage{caption}
\usepackage{threeparttable}
\captionsetup[table]{
    font=small,
    skip=10pt,
    labelfont=bf
}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\begin{document}

\begin{titlepage}
    \thispagestyle{empty}
    \centering
    \vspace*{5cm}
    {\Huge\bfseries Projekt:
Mobile Robotik DLBROESR01\_D \par}
    \vspace{1cm}
    {\Large Fallstudie \par}
    \vspace{0.5cm}
    {\large Studiengang: Angewandte Künstliche Intelligenz \par}
    \vspace{0.5cm}
    {\large Sven Behrens \par}
    \vspace{0.5cm}
    {\large Matrikelnummer: 42303511 \par}
    \vspace{0.5cm}
    {\large Prof. Dr. Florian Simroth \par}
    \vspace{0.5cm}
    {\large \today \par}
\end{titlepage}

\pagenumbering{Roman}
\setcounter{page}{1}

\tableofcontents
\newpage

\listoffigures
\addcontentsline{toc}{section}{Abbildungsverzeichnis}
\newpage

\listoftables
\addcontentsline{toc}{section}{Tabellenverzeichnis}
\newpage

\section*{Abkürzungsverzeichnis}
\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
\begin{acronym}[C-Space]
    \acro{AMR}{Automated Mobile Robot}
    \acro{C-Space}{Configuration Space}
    \acro{PRM}{Probabilistic Roadmap}
    \acro{RRT}{Rapidly-exploring Random Tree}
\end{acronym}
\newpage

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Einleitung}
Die Intralogistik befindet sich in einem tiefgreifenden Wandel. Angetrieben durch die steigende
Kundenerwartungen an Liefergeschwindigkeit setzen immer mehr Unternehmen auf automatisierte
mobile Roboter (\ac{AMR}) für den innerbetrieblichen Warentransport \parencite{fragapane2021amr}. 
Eine zentrale Herausforderung beim Einsatz solcher Systeme stellt die Pfadplanung dar: Der Roboter muss 
in der Lage sein, kollisionsfrei von einem Startpunkt zu einem Zielpunkt zu navigieren und dabei sowohl 
statische Hindernisse als auch die eigene Geometrie zu berücksichtigen. Vor diesem Hintergrund wurde im
Rahmen des Moduls \enquote{Mobile Robotik} an der IU Internationalen Hochschule ein Softwareprototyp
entwickelt, der verschiedene etablierte Pfadplanungsalgorithmen implementiert und vergleichend evaluiert.

Das primäre Projektziel bestand in der Implementierung eines Softwaresystems, das für einen omnidirektionalen 
Roboter in einer polygonbasierten Lagerumgebung kollisionsfreie Pfade berechnet. Die zentrale Forschungsfrage 
konzentrierte sich darauf, wie verschiedene Pfadplanungsalgorithmen hinsichtlich Pfadqualität, Rechenzeit und 
Robustheit in unterschiedlich komplexen Umgebungen performieren. Besondere Aufmerksamkeit galt dabei der 
korrekten Konstruktion des Konfigurationsraums (\ac{C-Space}), der die Robotergeometrie in die Hindernisdarstellung 
integriert.

Die methodische Vorgehensweise gliederte sich in mehrere aufeinander aufbauende Phasen. Zunächst wurde eine 
modulare Softwarearchitektur in Python entwickelt, die eine klare Trennung zwischen Umgebungsmodellierung, 
Robotergeometrie, Konfigurationsraumberechnung und Pfadplanung vorsieht. Anschließend wurden fünf verschiedene 
Algorithmen implementiert und verglichen: Die graphbasierten Verfahren A*, Dijkstra und Best-First-Search sowie 
die samplingbasierten Methoden \ac{RRT} und \ac{PRM}. Die Evaluation erfolgte auf drei Testumgebungen mit 
steigender Komplexität unter Verwendung von drei unterschiedlichen Robotergeometrien.

Der gewählte Ansatz zeichnet sich durch seine Erweiterbarkeit aus. Neben dem zweidimensionalen \ac{C-Space} für 
omnidirektionale Roboter wurde zusätzlich ein dreidimensionaler Konfigurationsraum implementiert, der die Orientierung 
des Roboters als dritte Dimension berücksichtigt. Dies ermöglicht die Pfadplanung für nicht-holonome Roboter 
und demonstriert die Skalierbarkeit des entwickelten Systems. Durch die systematische Evaluation verschiedener 
Algorithmus-Roboter-Umgebungs-Kombinationen wurden quantitative Erkenntnisse gewonnen, die als Entscheidungsgrundlage 
für den praktischen Einsatz dienen können.

Die vorliegende Fallstudie gliedert sich wie folgt: Nach der Beschreibung der Projektumgebung wird der iterative 
Entwicklungsansatz erläutert. Die Hauptabschnitte behandeln die 2D- und 3D-Pfadplanung mit ihren jeweiligen Ergebnissen. 
Abschließend werden die Projektergebnisse kritisch reflektiert und Verbesserungspotenziale aufgezeigt.

\section{Hauptteil}
\subsection{Projektumgebung}
Zu Beginn des Projekts wurde ein GitHub-Repository\footnote{\url{https://github.com/svenb23/mobile-robotik-pfadplanung}} angelegt, 
um eine nachvollziehbare Versionsverwaltung zu gewährleisten. Anschließend wurde eine virtuelle Python-Umgebung
mit \texttt{venv} eingerichtet, in der alle projektspezifischen Abhängigkeiten isoliert
installiert wurden. Als Implementierungssprache wurde Python gewählt, da der Autor hier über
die meiste Erfahrung verfügt.

\subsection{Zwei-Phasen-Analyseansatz}
Nach dem Einrichten der Projektstruktur wurde die Entwicklung in zwei aufeinander aufbauende
Phasen gegliedert. Diese Vorgehensweise ermöglichte es, zunächst die grundlegenden Konzepte
der Pfadplanung im einfacheren Fall zu validieren, bevor die Komplexität erhöht wurde.

In der ersten Phase wurde die Pfadplanung für omnidirektionale Roboter implementiert. Bei diesem
Robotertyp kann sich der Roboter in jede Richtung bewegen, ohne seine Orientierung ändern zu müssen.
Der resultierende Konfigurationsraum ist zweidimensional und umfasst lediglich die Position $(x, y)$
des Roboters. 

Die zweite Phase erweiterte das System um die Berücksichtigung der Roboter\-orientierung. Für
nicht-holonome Roboter, die sich nicht seitwärts bewegen können, ist die Orientierung $\theta$
eine zusätzliche Freiheitsdimension. Der Konfigurationsraum wird dadurch dreidimensional $(x, y, \theta)$,
was die Komplexität der Kollisionsprüfung und Pfadsuche erheblich steigert. Durch den modularen
Aufbau der ersten Phase konnten wesentliche Komponenten wiederverwendet und gezielt erweitert werden.

\subsection{2D-Pfadplanung}
\subsubsection{Umgebungsmodellierung}
Die Lagerumgebung wird durch eine rechteckige Grundfläche mit polygonalen Hindernissen modelliert.
Jedes Hindernis ist als Liste von Eckpunkten definiert, die ein geschlossenes Polygon bilden.
Diese Repräsentation ermöglicht eine flexible Darstellung beliebiger konvexer und konkaver
Hindernisformen.

Für die Evaluation wurden drei Testumgebungen mit steigender Komplexität erstellt. Die
\textit{easy}-Umgebung umfasst eine Fläche von $20 \times 15$ Metern mit zwei rechteckigen
Hindernissen, die einen einfachen Umweg erfordern. Die \textit{medium}-Umgebung erweitert
die Fläche auf $25 \times 20$ Meter und enthält sechs Hindernisse, die korridorartige
Strukturen bilden. Die \textit{hard}-Umgebung stellt mit $30 \times 25$ Metern und 14
Hindernissen eine labyrinthartige Struktur dar, die deutlich komplexere Pfade erfordert
(siehe \cref{fig:maps_overview} im Anhang).

\subsubsection{Robotergeometrie}
Der Roboter wird als Polygon modelliert, dessen Eckpunkte relativ zum Ursprung definiert sind.
Diese Darstellung ermöglicht eine einheitliche Behandlung beliebiger Roboterformen bei der
Kollisionsprüfung. Die Methode \texttt{at(x, y, theta)} transformiert das Roboterpolygon
an eine beliebige Position mit optionaler Rotation.

Für die Evaluation wurden drei unterschiedliche Geometrien implementiert. Der kreisförmige
Roboter mit einem Radius von 0,5 Metern wird als 16-Eck approximiert und repräsentiert einen
omnidirektionalen Roboter ohne bevorzugte Ausrichtung. Der rechteckige Roboter mit den
Abmessungen $0{,}8 \times 0{,}5$ Meter entspricht einem typischen Transportroboter.
Der dreieckige Roboter mit einer Basis von 0,8 Metern und einer Höhe von 0,6 Metern
zeigt mit seiner Spitze nach vorne, kann sich jedoch als omnidirektionaler Roboter
in alle Richtungen bewegen. Diese asymmetrische Form verdeutlicht den Einfluss der
Geometrie auf den Konfigurationsraum (siehe \cref{fig:robot_geometries} im Anhang).

\subsubsection{Konfigurationsraumberechnung}
Der Konfigurationsraum (\ac{C-Space}) transformiert das Pfadplanungsproblem von einem
ausgedehnten Roboter zu einem Punktroboter. Dabei werden die Hindernisse um die
Robotergeometrie erweitert, sodass eine Kollisionsprüfung nur noch für den Referenzpunkt
des Roboters erforderlich ist.

Die Berechnung erfolgt durch Diskretisierung des Arbeitsraums in ein gleichmäßiges Gitter
mit konfigurierbarer Auflösung (Standard: 0,5 Meter). Für jede Gitterzelle wird das
Roboterpolygon an der entsprechenden Position platziert und mittels der Shapely-Bibliothek
\parencite{shapely2024} auf Überschneidungen mit den Hindernissen geprüft. Zusätzlich wird sichergestellt, dass
der Roboter vollständig innerhalb der Umgebungsgrenzen liegt. Das Ergebnis ist ein
boolesches 2D-Array, in dem besetzte Zellen als \texttt{True} und freie Zellen als
\texttt{False} markiert sind.

Durch diese Vorverarbeitung reduziert sich die Pfadplanung auf eine Graphsuche im
diskretisierten Gitter. Die gewählte Auflösung stellt einen Kompromiss zwischen
Genauigkeit und Rechenaufwand dar (siehe \cref{fig:cspace_comparison} im Anhang).

\subsubsection{Pfadplanungsalgorithmen}
Für die Pfadsuche wurden fünf Algorithmen aus zwei Kategorien implementiert: graphbasierte
und samplingbasierte Verfahren.

Die graphbasierten Algorithmen arbeiten auf dem diskretisierten Konfigurationsraum und nutzen
die pathfinding-Bibliothek. A* bewertet jeden Knoten nach der Summe $f(n) = g(n) + h(n)$,
wobei $g(n)$ die tatsächlichen Kosten vom Start und $h(n)$ eine heuristische Schätzung zum
Ziel darstellt. Der Algorithmus expandiert stets den Knoten mit dem niedrigsten $f$-Wert
und findet garantiert den kürzesten Pfad bei zulässiger Heuristik
\parencite[S. 312--314]{lynch2017modern}. Dijkstra ist ein Spezialfall von A* mit
$h(n) = 0$ und expandiert Knoten ausschließlich nach ihren bisherigen Kosten $g(n)$
\parencite[S. 314]{lynch2017modern}. Dies liefert ebenfalls optimale Pfade, exploriert
jedoch mehr Knoten, da keine Richtungsinformation zum Ziel genutzt wird. Best-First-Search
verwendet ausschließlich die Heuristik $h(n)$ und ignoriert die bisherigen Kosten. Dadurch
findet der Algorithmus schnell einen Pfad zum Ziel, dieser ist jedoch nicht zwangsläufig
optimal. Alle drei Algorithmen erlauben diagonale Bewegungen im Gitter und sind
vollständig, das heißt sie finden garantiert eine Lösung, sofern eine existiert.

Die samplingbasierten Algorithmen wurden eigenständig implementiert und arbeiten im
kontinuierlichen Raum. \ac{RRT} baut einen Baum ausgehend vom Startpunkt auf. In jeder
Iteration wird ein zufälliger Punkt im Raum gesampelt, der nächste Knoten im Baum bestimmt
und ein neuer Knoten in Richtung des Samples mit einer festen Schrittweite (0,5 Meter)
hinzugefügt. Eine Zielgewichtung von 10\% sorgt dafür, dass der Baum gezielt zum Ziel wächst
\parencite[S. 324--325]{lynch2017modern}. \ac{PRM} arbeitet in zwei Phasen: Zunächst
werden 500 zufällige, kollisionsfreie Punkte im Raum verteilt. Anschließend wird jeder Punkt
mit seinen 10 nächsten Nachbarn verbunden, sofern die Verbindung kollisionsfrei ist. Die
Pfadsuche erfolgt mittels A* auf diesem vorberechneten Graphen
\parencite[S. 328--330]{lynch2017modern}. Beide Verfahren sind probabilistisch
vollständig: Mit zunehmender Anzahl an Samples konvergiert die Wahrscheinlichkeit,
eine existierende Lösung zu finden, gegen eins. Sie eignen sich besonders für
hochdimensionale Konfigurationsräume
(siehe \cref{fig:algorithm_comparison} im Anhang).

\subsubsection{Evaluation}
Die Evaluation erfolgte systematisch über alle Kombinationen aus drei Testumgebungen,
drei Robotergeometrien und fünf Algorithmen. Als Metriken wurden die Pfadlänge,
die Anzahl der Wegpunkte und die Rechenzeit erfasst.

Die graphbasierten Algorithmen A* und Dijkstra lieferten in allen Testfällen
optimale Pfadlängen. Dies bestätigt die theoretische Äquivalenz beider Verfahren bei
Verwendung einer zulässigen Heuristik. Best-First-Search erreichte die kürzesten
Rechenzeiten, produzierte jedoch um 10--15\% längere Pfade, da die Optimierung
zugunsten der Geschwindigkeit vernachlässigt wird.

Bei den samplingbasierten Verfahren zeigte \ac{RRT} eine hohe Zuverlässigkeit und fand
in allen Testfällen einen Pfad. Die resultierenden Pfade waren jedoch 15--20\% länger
als die optimalen Lösungen, was dem explorativen Charakter des Algorithmus entspricht.
\ac{PRM} lieferte in einfachen Umgebungen effiziente Pfade mit wenigen Wegpunkte,
scheiterte jedoch in der \textit{hard}-Umgebung bei rechteckiger und dreieckiger
Robotergeometrie. Die zufällige Verteilung der Samples konnte in diesen Fällen keine
durchgängige Verbindung durch die engen Korridore herstellen
(siehe \cref{fig:comparison_hard} im Anhang).

Die Rechenzeiten stiegen erwartungsgemäß mit der Umgebungskomplexität. Während
alle Algorithmen in der \textit{easy}-Umgebung unter 0,1 Sekunden benötigten,
erreichte \ac{RRT} in der \textit{hard}-Umgebung Rechenzeiten von bis zu 0,5 Sekunden.
Die Robotergeometrie hatte hingegen nur minimalen Einfluss auf die Performance,
da die Kollisionsprüfung durch den vorberechneten Konfigurationsraum effizient erfolgt
(siehe \cref{tab:results_2d} im Anhang).

\subsection{3D-Pfadplanung}
\subsubsection{Umgebungsmodellierung}
Für die 3D-Pfadplanung wurde die \textit{hard}-Umgebung aus der 2D-Evaluation wiederverwendet.
Diese Wahl ermöglicht einen direkten Vergleich der Ergebnisse und demonstriert die erhöhte
Komplexität durch die zusätzliche Orientierungsdimension in einer bereits anspruchsvollen
Umgebung.

\subsubsection{Robotergeometrie}
Als Robotergeometrie wurde ausschließlich ein rechteckiger Roboter mit den Abmessungen
$1{,}0 \times 0{,}5$ Meter verwendet. Die 2D-Evaluation zeigte, dass die Robotergeometrie
nur minimalen Einfluss auf den Algorithmusvergleich hat, weshalb für die 3D-Pfadplanung
auf die Variation der Roboterformen verzichtet wurde.

\subsubsection{Konfigurationsraumberechnung}
Der dreidimensionale Konfigurationsraum erweitert die 2D-Repräsentation um die
Orientierung $\theta$ als dritte Dimension. Die Diskretisierung erfolgt mit einer
räumlichen Auflösung von 0,5 Metern und 12 Winkelschritten, was einer Winkelauflösung
von 30° entspricht.

Für jede Kombination aus Position $(x, y)$ und Orientierung $\theta$ wird das
rotierte Roboterpolygon auf Kollisionen mit Hindernissen und Umgebungsgrenzen geprüft.
Die Berechnung ist rechenintensiver als im 2D-Fall, da für jeden Gitterpunkt zwölf
Orientierungen evaluiert werden müssen. Das Ergebnis ist ein dreidimensionales
boolesches Array, das die Befahrbarkeit jeder Konfiguration angibt.

\subsubsection{Pfadplanungsalgorithmen}
Für die 3D-Pfadplanung wurden vier Algorithmen implementiert: A*, Dijkstra, \ac{RRT}
und \ac{PRM}. Die graphbasierten Verfahren A* und Dijkstra operieren auf dem 3D-Gitter
mit einer erweiterten Nachbarschaftsdefinition: Neben der 8-Nachbarschaft in der
xy-Ebene werden für jede Position drei Optionen für die Orientierung berücksichtigt
(unverändert, +30°, -30°).

Die samplingbasierten Verfahren \ac{RRT} und \ac{PRM} wurden für den dreidimensionalen
Raum $(x, y, \theta)$ angepasst. Bei der Bewegung zwischen zwei Konfigurationen wird
sowohl die räumliche Distanz als auch die Winkeländerung interpoliert und auf
Kollisionsfreiheit geprüft.

\subsubsection{Evaluation}
Die Evaluation wurde mit einem Startpunkt bei $(1, 1, 0°)$ und einem Zielpunkt
bei $(7, 2, 180°)$ durchgeführt. Diese Konfiguration erfordert nicht nur eine
räumliche Navigation durch die Hindernisse, sondern auch eine Drehung des
Roboters um 180°.

A* und Dijkstra fanden optimale Pfade mit einer Länge von 66,5 Metern bei
Rechenzeiten von 0,74 bzw. 0,68 Sekunden. \ac{RRT} benötigte mit 8,69 Sekunden
deutlich mehr Rechenzeit und lieferte einen längeren Pfad von 79,3 Metern.
\ac{PRM} erzielte mit 72,7 Metern und 0,22 Sekunden einen guten Kompromiss
zwischen Pfadqualität und Rechenzeit.

Obwohl samplingbasierte Verfahren theoretisch besser mit höheren Dimensionen
skalieren \parencite[S. 1]{petrovic2018motion}, zeigt sich dieser Vorteil
bei nur drei Dimensionen noch nicht deutlich.
Die graphbasierten Verfahren profitieren hier von der noch handhabbaren Gittergröße.
In strukturierten Umgebungen mit engen Korridoren haben samplingbasierte Verfahren
zudem Schwierigkeiten, da zufällige Samples selten die schmalen Durchgänge treffen
(siehe \cref{fig:cspace3d_comparison} und \cref{tab:results_3d} im Anhang).

\section{Fazit}
\subsection{Zielerreichung und Projektergebnisse}
Das primäre Projektziel, ein Softwaresystem zur kollisionsfreien Pfadplanung für
mobile Roboter in polygonbasierten Lagerumgebungen zu entwickeln, wurde vollständig
erreicht. Die implementierte Lösung ermöglicht die Berechnung von Pfaden sowohl
für omnidirektionale Roboter im 2D-Konfigurationsraum als auch für orientierungsabhängige
Roboter im 3D-Konfigurationsraum.

Die systematische Evaluation von fünf Algorithmen auf drei Testumgebungen mit
unterschiedlichen Robotergeometrien lieferte quantitative Erkenntnisse über die
Stärken und Schwächen der verschiedenen Ansätze. A* und Dijkstra erwiesen sich
als zuverlässige Verfahren für optimale Pfade, während Best-First-Search bei
Zeitkritikalität Vorteile bietet. Die samplingbasierten Verfahren RRT und PRM
zeigten ihre Eignung für komplexere Szenarien, offenbarten jedoch Schwächen in
Umgebungen mit engen Korridoren.

\subsection{Kritische Reflexion}
Die gewählte Diskretisierung des Konfigurationsraums stellt einen Kompromiss dar.
Eine feinere Auflösung würde präzisere Pfade ermöglichen, erhöht jedoch den
Speicherbedarf und die Rechenzeit erheblich. Besonders im 3D-Fall mit zwölf
Winkelschritten ist die Auflösung relativ grob, was zu suboptimalen Pfaden
führen kann.

Die Evaluation basiert auf einzelnen Durchläufen pro Konfiguration. Da RRT und
PRM auf Zufallszahlen basieren, können die Ergebnisse bei wiederholter Ausführung
variieren. Eine statistisch robustere Evaluation würde Mehrfachdurchläufe mit
Mittelwertbildung erfordern.

Die Testumgebungen sind statisch und repräsentieren idealisierte Lagerhallen.
Reale Einsatzszenarien umfassen dynamische Hindernisse, Unsicherheiten in der
Lokalisierung und Sensorrauschen, die in dieser Arbeit nicht berücksichtigt wurden.

\subsection{Verbesserungspotenziale und Optimierungsansätze}
Die Pfadqualität könnte durch Nachbearbeitung verbessert werden. Pfadglättungsalgorithmen
würden die kantigen Trajektorien der gitterbasierten Verfahren in fahrbare Kurven
umwandeln. Für die samplingbasierten Verfahren existieren Varianten wie RRT* und
PRM*, die asymptotisch optimale Pfade garantieren
\parencite[S. 1]{karaman2011sampling}.

Die Rechenzeit ließe sich durch adaptive Auflösung reduzieren. In freien Bereichen
genügt eine grobe Diskretisierung, während in der Nähe von Hindernissen eine
feinere Auflösung sinnvoll wäre. Hierarchische Ansätze könnten zunächst auf
grobem Gitter planen und nur relevante Bereiche verfeinern.

Eine Erweiterung auf höherdimensionale Konfigurationsräume wäre ebenfalls denkbar.
Roboterarme mit sechs oder mehr Freiheitsgraden erfordern entsprechend viele
Dimensionen. In solchen Szenarien würden die samplingbasierten Verfahren ihre
Stärken gegenüber gitterbasierten Methoden deutlicher ausspielen können.

Neben den implementierten Algorithmen existieren weitere Ansätze, die das System
ergänzen könnten. Die Potentialfeld-Methode modelliert das Ziel als anziehende
und Hindernisse als abstoßende Kräfte, wodurch der Roboter entlang des
Gradientenabstiegs zum Ziel navigiert. Trajektorienoptimierungsverfahren wie
CHOMP \parencite{ratliff2009chomp} oder TrajOpt \parencite{schulman2014trajopt} könnten 
die gefundenen Pfade hinsichtlich Glätte und Energieeffizienz nachoptimieren.

\subsection{Ausblick}

\section*{Projektrepository}
\addcontentsline{toc}{section}{Projektrepository}
Der vollständige Quellcode ist im GitHub-Repository verfügbar: \url{https://github.com/svenb23/mobile-robotik-pfadplanung}

\newpage

\printbibliography
\addcontentsline{toc}{section}{Literaturverzeichnis}

\newpage
\section*{Verzeichnis der Anhänge}
\addcontentsline{toc}{section}{Verzeichnis der Anhänge}

\appendix
\section*{Anhang}
\addcontentsline{toc}{section}{Anhang}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/maps_overview.png}
    \caption{Übersicht der drei Testumgebungen: easy (links), medium (Mitte), hard (rechts)}
    \label{fig:maps_overview}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../figures/robot_geometries.png}
    \caption{Die drei Robotergeometrien: Kreis (links), Rechteck (Mitte), Dreieck (rechts)}
    \label{fig:robot_geometries}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/cspace_comparison.png}
    \caption{Konfigurationsräume für verschiedene Robotergeometrien: Die grauen Bereiche zeigen die erweiterten Hindernisse}
    \label{fig:cspace_comparison}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/algorithm_comparison.png}
    \caption{Vergleich der Pfadplanungsalgorithmen: Unterschiedliche Strategien führen zu verschiedenen Pfadverläufen}
    \label{fig:algorithm_comparison}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/comparison_hard.png}
    \caption{Evaluationsergebnisse in der \textit{hard}-Umgebung: PRM scheitert bei rechteckiger und dreieckiger Robotergeometrie (rechte Spalte, mittlere und untere Zeile)}
    \label{fig:comparison_hard}
\end{figure}

\begin{table}[H]
\centering
\caption{Evaluationsergebnisse der 2D-Pfadplanung (kreisförmiger Roboter)}
\label{tab:results_2d}
\begin{tabular}{llrrr}
\toprule
Umgebung & Algorithmus & Pfadlänge [m] & Wegpunkte & Zeit [s] \\
\midrule
easy & A* & 23,65 & 67 & 0,010 \\
easy & Dijkstra & 23,65 & 67 & 0,017 \\
easy & Best-First & 24,60 & 71 & 0,004 \\
easy & RRT & 28,18 & 58 & 0,018 \\
easy & PRM & 23,31 & 21 & 0,106 \\
\midrule
medium & A* & 41,72 & 121 & 0,020 \\
medium & Dijkstra & 41,72 & 121 & 0,019 \\
medium & Best-First & 50,69 & 148 & 0,010 \\
medium & RRT & 51,00 & 104 & 0,125 \\
medium & PRM & 45,88 & 25 & 0,067 \\
\midrule
hard & A* & 53,12 & 164 & 0,022 \\
hard & Dijkstra & 53,12 & 164 & 0,023 \\
hard & Best-First & 58,80 & 185 & 0,012 \\
hard & RRT & 62,02 & 126 & 0,414 \\
hard & PRM & 55,04 & 22 & 0,045 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/cspace3d_comparison.png}
    \caption{3D-Konfigurationsraum mit Pfaden der vier Algorithmen: Die Hindernisse erstrecken sich als vertikale Wände durch alle Orientierungen}
    \label{fig:cspace3d_comparison}
\end{figure}

\begin{table}[H]
\centering
\caption{Evaluationsergebnisse der 3D-Pfadplanung (rechteckiger Roboter, \textit{hard}-Umgebung)}
\label{tab:results_3d}
\begin{tabular}{lrrr}
\toprule
Algorithmus & Pfadlänge [m] & Wegpunkte & Zeit [s] \\
\midrule
A* & 66,50 & -- & 0,74 \\
Dijkstra & 66,50 & -- & 0,68 \\
RRT & 79,30 & -- & 8,69 \\
PRM & 72,70 & -- & 0,22 \\
\bottomrule
\end{tabular}
\end{table}

\end{document}
