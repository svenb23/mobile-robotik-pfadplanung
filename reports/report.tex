\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{array}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{float}

\usepackage[scaled]{helvet}
\renewcommand{\familydefault}{\sfdefault}

\usepackage[a4paper, top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{setspace}
\setstretch{1.5}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt}

\usepackage{microtype}
\sloppy
\hyphenpenalty=1000
\tolerance=3000

\renewcommand{\footnotesize}{\fontsize{10}{12}\selectfont}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\usepackage{titlesec}
\titleformat{\section}{\normalfont\fontsize{12}{14}\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\fontsize{12}{14}\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\fontsize{12}{14}\bfseries}{\thesubsubsection}{1em}{}

\usepackage[
  colorlinks=true,
  linkcolor=black,
  citecolor=blue,
  filecolor=black,
  urlcolor=blue
]{hyperref}
\usepackage[capitalise,nameinlink]{cleveref}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[C]{\thepage}

\usepackage[backend=biber, style=apa]{biblatex}
\addbibresource{references.bib}

\usepackage{titling}

\usepackage{acronym}
\usepackage[german=quotes]{csquotes}

\usepackage{caption}
\usepackage{threeparttable}
\captionsetup[table]{
    font=small,
    skip=10pt,
    labelfont=bf
}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\begin{document}

\begin{titlepage}
    \thispagestyle{empty}
    \centering
    \vspace*{5cm}
    {\Huge\bfseries Projekt:
Mobile Robotik DLBROESR01\_D \par}
    \vspace{1cm}
    {\Large Fallstudie \par}
    \vspace{0.5cm}
    {\large Studiengang: Angewandte Künstliche Intelligenz \par}
    \vspace{0.5cm}
    {\large Sven Behrens \par}
    \vspace{0.5cm}
    {\large Matrikelnummer: 42303511 \par}
    \vspace{0.5cm}
    {\large Prof. Dr. Florian Simroth \par}
    \vspace{0.5cm}
    {\large \today \par}
\end{titlepage}

\pagenumbering{Roman}
\setcounter{page}{1}

\tableofcontents
\newpage

\listoffigures
\addcontentsline{toc}{section}{Abbildungsverzeichnis}
\newpage

\listoftables
\addcontentsline{toc}{section}{Tabellenverzeichnis}
\newpage

\section*{Abkürzungsverzeichnis}
\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
\begin{acronym}[C-Space]
    \acro{AMR}{Automated Mobile Robot}
    \acro{C-Space}{Configuration Space}
    \acro{PRM}{Probabilistic Roadmap}
    \acro{RRT}{Rapidly-exploring Random Tree}
\end{acronym}
\newpage

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Einleitung}
Die Intralogistik befindet sich in einem tiefgreifenden Wandel. Angetrieben durch die steigende
Kundenerwartungen an Liefergeschwindigkeit setzen immer mehr Unternehmen auf automatisierte
mobile Roboter (\ac{AMR}) für den innerbetrieblichen Warentransport \parencite{fragapane2021amr}. 
Eine zentrale Herausforderung beim Einsatz solcher Systeme stellt die Pfadplanung dar: Der Roboter muss 
in der Lage sein, kollisionsfrei von einem Startpunkt zu einem Zielpunkt zu navigieren und dabei sowohl 
statische Hindernisse als auch die eigene Geometrie zu berücksichtigen. Vor diesem Hintergrund wurde im
Rahmen des Moduls \enquote{Mobile Robotik} an der IU Internationalen Hochschule ein Softwareprototyp
entwickelt, der verschiedene etablierte Pfadplanungsalgorithmen implementiert und vergleichend evaluiert.

Das primäre Projektziel bestand in der Implementierung eines Softwaresystems, das für einen omnidirektionalen 
Roboter in einer polygonbasierten Lagerumgebung kollisionsfreie Pfade berechnet. Die zentrale Forschungsfrage 
konzentrierte sich darauf, wie verschiedene Pfadplanungsalgorithmen hinsichtlich Pfadqualität, Rechenzeit und 
Robustheit in unterschiedlich komplexen Umgebungen performieren. Besondere Aufmerksamkeit galt dabei der 
korrekten Konstruktion des Konfigurationsraums (\ac{C-Space}), der die Robotergeometrie in die Hindernisdarstellung 
integriert.

Die methodische Vorgehensweise gliederte sich in mehrere aufeinander aufbauende Phasen. Zunächst wurde eine 
modulare Softwarearchitektur in Python entwickelt, die eine klare Trennung zwischen Umgebungsmodellierung, 
Robotergeometrie, Konfigurationsraumberechnung und Pfadplanung vorsieht. Anschließend wurden fünf verschiedene 
Algorithmen implementiert und verglichen: Die graphbasierten Verfahren A*, Dijkstra und Best-First-Search sowie 
die samplingbasierten Methoden \ac{RRT} und \ac{PRM}. Die Evaluation erfolgte auf drei Testumgebungen mit 
steigender Komplexität unter Verwendung von drei unterschiedlichen Robotergeometrien.

Der gewählte Ansatz zeichnet sich durch seine Erweiterbarkeit aus. Neben dem zweidimensionalen \ac{C-Space} für 
omnidirektionale Roboter wurde zusätzlich ein dreidimensionaler Konfigurationsraum implementiert, der die Orientierung 
des Roboters als dritte Dimension berücksichtigt. Dies ermöglicht die Pfadplanung für nicht-holonome Roboter 
und demonstriert die Skalierbarkeit des entwickelten Systems. Durch die systematische Evaluation verschiedener 
Algorithmus-Roboter-Umgebungs-Kombinationen wurden quantitative Erkenntnisse gewonnen, die als Entscheidungsgrundlage 
für den praktischen Einsatz dienen können.

Die vorliegende Fallstudie gliedert sich wie folgt: Nach der Beschreibung der Projektumgebung wird der iterative 
Entwicklungsansatz erläutert. Die Hauptabschnitte behandeln die 2D- und 3D-Pfadplanung mit ihren jeweiligen Ergebnissen. 
Abschließend werden die Projektergebnisse kritisch reflektiert und Verbesserungspotenziale aufgezeigt.

\section{Hauptteil}
\subsection{Projektumgebung}
Zu Beginn des Projekts wurde ein GitHub-Repository\footnote{\url{https://github.com/svenb23/mobile-robotik-pfadplanung}} angelegt, 
um eine nachvollziehbare Versionsverwaltung zu gewährleisten. Anschließend wurde eine virtuelle Python-Umgebung
mit \texttt{venv} eingerichtet, in der alle projektspezifischen Abhängigkeiten isoliert
installiert wurden. Als Implementierungssprache wurde Python gewählt, da der Autor hier über
die meiste Erfahrung verfügt.

\subsection{Zwei-Phasen-Analyseansatz}
Nach dem Einrichten der Projektstruktur wurde die Entwicklung in zwei aufeinander aufbauende
Phasen gegliedert. Diese Vorgehensweise ermöglichte es, zunächst die grundlegenden Konzepte
der Pfadplanung im einfacheren Fall zu validieren, bevor die Komplexität erhöht wurde.

In der ersten Phase wurde die Pfadplanung für omnidirektionale Roboter implementiert. Bei diesem
Robotertyp kann sich der Roboter in jede Richtung bewegen, ohne seine Orientierung ändern zu müssen.
Der resultierende Konfigurationsraum ist zweidimensional und umfasst lediglich die Position $(x, y)$
des Roboters. 

Die zweite Phase erweiterte das System um die Berücksichtigung der Roboter\-orientierung. Für
nicht-holonome Roboter, die sich nicht seitwärts bewegen können, ist die Orientierung $\theta$
eine zusätzliche Freiheitsdimension. Der Konfigurationsraum wird dadurch dreidimensional $(x, y, \theta)$,
was die Komplexität der Kollisionsprüfung und Pfadsuche erheblich steigert. Durch den modularen
Aufbau der ersten Phase konnten wesentliche Komponenten wiederverwendet und gezielt erweitert werden.

\subsection{2D-Pfadplanung}
\subsubsection{Umgebungsmodellierung}
Die Lagerumgebung wird durch eine rechteckige Grundfläche mit polygonalen Hindernissen modelliert.
Jedes Hindernis ist als Liste von Eckpunkten definiert, die ein geschlossenes Polygon bilden.
Diese Repräsentation ermöglicht eine flexible Darstellung beliebiger konvexer und konkaver
Hindernisformen.

Für die Evaluation wurden drei Testumgebungen mit steigender Komplexität erstellt. Die
\textit{easy}-Umgebung umfasst eine Fläche von $20 \times 15$ Metern mit zwei rechteckigen
Hindernissen, die einen einfachen Umweg erfordern. Die \textit{medium}-Umgebung erweitert
die Fläche auf $25 \times 20$ Meter und enthält sechs Hindernisse, die korridorartige
Strukturen bilden. Die \textit{hard}-Umgebung stellt mit $30 \times 25$ Metern und 14
Hindernissen eine labyrinthartige Struktur dar, die deutlich komplexere Pfade erfordert
(siehe \cref{fig:maps_overview} im Anhang).

\subsubsection{Robotergeometrie}
Der Roboter wird als Polygon modelliert, dessen Eckpunkte relativ zum Ursprung definiert sind.
Diese Darstellung ermöglicht eine einheitliche Behandlung beliebiger Roboterformen bei der
Kollisionsprüfung. Die Methode \texttt{at(x, y, theta)} transformiert das Roboterpolygon
an eine beliebige Position mit optionaler Rotation.

Für die Evaluation wurden drei unterschiedliche Geometrien implementiert. Der kreisförmige
Roboter mit einem Radius von 0,5 Metern wird als 16-Eck approximiert und repräsentiert einen
omnidirektionalen Roboter ohne bevorzugte Ausrichtung. Der rechteckige Roboter mit den
Abmessungen $0{,}8 \times 0{,}5$ Meter entspricht einem typischen Transportroboter.
Der dreieckige Roboter mit einer Basis von 0,8 Metern und einer Höhe von 0,6 Metern
zeigt mit seiner Spitze nach vorne, kann sich jedoch als omnidirektionaler Roboter
in alle Richtungen bewegen. Diese asymmetrische Form verdeutlicht den Einfluss der
Geometrie auf den Konfigurationsraum (siehe \cref{fig:robot_geometries} im Anhang).

\subsubsection{Konfigurationsraumberechnung}
Der Konfigurationsraum (\ac{C-Space}) transformiert das Pfadplanungsproblem von einem
ausgedehnten Roboter zu einem Punktroboter. Dabei werden die Hindernisse um die
Robotergeometrie erweitert, sodass eine Kollisionsprüfung nur noch für den Referenzpunkt
des Roboters erforderlich ist.

Die Berechnung erfolgt durch Diskretisierung des Arbeitsraums in ein gleichmäßiges Gitter
mit konfigurierbarer Auflösung (für die 2D-Evaluation: 0,3 Meter). Für jede Gitterzelle wird das
Roboterpolygon an der entsprechenden Position platziert und mittels der Shapely-Bibliothek
\parencite{shapely2024} auf Überschneidungen mit den Hindernissen geprüft. Zusätzlich wird sichergestellt, dass
der Roboter vollständig innerhalb der Umgebungsgrenzen liegt. Das Ergebnis ist ein
boolesches 2D-Array, in dem besetzte Zellen als \texttt{True} und freie Zellen als
\texttt{False} markiert sind.

Durch diese Vorverarbeitung reduziert sich die Pfadplanung auf eine Graphsuche im
diskretisierten Gitter. Die gewählte Auflösung stellt einen Kompromiss zwischen
Genauigkeit und Rechenaufwand dar (siehe \cref{fig:cspace_comparison} im Anhang).

\subsubsection{Pfadplanungsalgorithmen}
Für die Pfadsuche wurden fünf Algorithmen aus zwei Kategorien implementiert: graphbasierte
und samplingbasierte Verfahren.

Die graphbasierten Algorithmen arbeiten auf dem diskretisierten Konfigurationsraum und nutzen
die pathfinding-Bibliothek. A* bewertet jeden Knoten nach der Summe $f(n) = g(n) + h(n)$,
wobei $g(n)$ die tatsächlichen Kosten vom Start und $h(n)$ eine heuristische Schätzung zum
Ziel darstellt. Der Algorithmus expandiert stets den Knoten mit dem niedrigsten $f$-Wert
und findet garantiert den kürzesten Pfad bei zulässiger Heuristik
\parencite[S. 312--314]{lynch2017modern}. Dijkstra ist ein Spezialfall von A* mit
$h(n) = 0$ und expandiert Knoten ausschließlich nach ihren bisherigen Kosten $g(n)$
\parencite[S. 314]{lynch2017modern}. Dies liefert ebenfalls optimale Pfade, exploriert
jedoch mehr Knoten, da keine Richtungsinformation zum Ziel genutzt wird. Best-First-Search
verwendet ausschließlich die Heuristik $h(n)$ und ignoriert die bisherigen Kosten. Dadurch
findet der Algorithmus schnell einen Pfad zum Ziel, dieser ist jedoch nicht zwangsläufig
optimal. Alle drei Algorithmen erlauben diagonale Bewegungen im Gitter und sind
vollständig, das heißt sie finden garantiert eine Lösung, sofern eine existiert.

Die samplingbasierten Algorithmen wurden eigenständig implementiert und arbeiten im
kontinuierlichen Raum. \ac{RRT} baut einen Baum ausgehend vom Startpunkt auf. In jeder
Iteration wird ein zufälliger Punkt im Raum gesampelt, der nächste Knoten im Baum bestimmt
und ein neuer Knoten in Richtung des Samples mit einer festen Schrittweite (0,5 Meter)
hinzugefügt. Eine Zielgewichtung von 10\% sorgt dafür, dass der Baum gezielt zum Ziel wächst
\parencite[S. 324--325]{lynch2017modern}. \ac{PRM} arbeitet in zwei Phasen: Zunächst
werden 500 zufällige, kollisionsfreie Punkte im Raum verteilt. Anschließend wird jeder Punkt
mit seinen 10 nächsten Nachbarn verbunden, sofern die Verbindung kollisionsfrei ist. Die
Pfadsuche erfolgt mittels A* auf diesem vorberechneten Graphen
\parencite[S. 328--330]{lynch2017modern}. Beide Verfahren sind probabilistisch
vollständig: Mit zunehmender Anzahl an Samples konvergiert die Wahrscheinlichkeit,
eine existierende Lösung zu finden, gegen eins. Sie eignen sich besonders für
hochdimensionale Konfigurationsräume
(siehe \cref{fig:algorithm_comparison} im Anhang).

\subsubsection{Evaluation}
Die Evaluation erfolgte systematisch über alle Kombinationen aus drei Testumgebungen,
drei Robotergeometrien und fünf Algorithmen. Als Metriken wurden die Pfadlänge,
die Anzahl der Wegpunkte und die Rechenzeit erfasst.

Die graphbasierten Algorithmen A* und Dijkstra lieferten in allen Testfällen
optimale Pfadlängen. Dies bestätigt die theoretische Äquivalenz beider Verfahren bei
Verwendung einer zulässigen Heuristik. Best-First-Search erreichte die kürzesten
Rechenzeiten, produzierte jedoch um 10--15\% längere Pfade, da die Optimierung
zugunsten der Geschwindigkeit vernachlässigt wird.

Bei den samplingbasierten Verfahren zeigte \ac{RRT} eine hohe Zuverlässigkeit und fand
in allen Testfällen einen Pfad. Die resultierenden Pfade waren jedoch 15--20\% länger
als die optimalen Lösungen, was dem explorativen Charakter des Algorithmus entspricht.
\ac{PRM} lieferte in einfachen Umgebungen effiziente Pfade mit wenigen Wegpunkte,
scheiterte jedoch in der \textit{hard}-Umgebung bei rechteckiger und dreieckiger
Robotergeometrie. Die zufällige Verteilung der Samples konnte in diesen Fällen keine
durchgängige Verbindung durch die engen Korridore herstellen
(siehe \cref{fig:comparison_hard} im Anhang).

Die Rechenzeiten stiegen erwartungsgemäß mit der Umgebungskomplexität. Während
alle Algorithmen in der \textit{easy}-Umgebung unter 0,1 Sekunden benötigten,
erreichte \ac{RRT} in der \textit{hard}-Umgebung Rechenzeiten von bis zu 0,5 Sekunden.
Die Robotergeometrie hatte hingegen nur minimalen Einfluss auf die Performance,
da die Kollisionsprüfung durch den vorberechneten Konfigurationsraum effizient erfolgt
(siehe \cref{tab:results_2d} im Anhang).

\subsection{3D-Pfadplanung}
\subsubsection{Umgebungsmodellierung}
Für die 3D-Pfadplanung wurde die \textit{hard}-Umgebung aus der 2D-Evaluation wiederverwendet.
Diese Wahl ermöglicht einen direkten Vergleich der Ergebnisse und demonstriert die erhöhte
Komplexität durch die zusätzliche Orientierungsdimension in einer bereits anspruchsvollen
Umgebung.

\subsubsection{Robotergeometrie}
Als Robotergeometrie wurde ausschließlich ein rechteckiger Roboter mit den Abmessungen
$1{,}0 \times 0{,}5$ Meter verwendet. Die 2D-Evaluation zeigte, dass die Robotergeometrie
nur minimalen Einfluss auf den Algorithmusvergleich hat, weshalb für die 3D-Pfadplanung
auf die Variation der Roboterformen verzichtet wurde.

\subsubsection{Konfigurationsraumberechnung}
Der dreidimensionale Konfigurationsraum erweitert die 2D-Repräsentation um die
Orientierung $\theta$ als dritte Dimension. Die Diskretisierung erfolgt mit einer
räumlichen Auflösung von 0,5 Metern und 12 Winkelschritten, was einer Winkelauflösung
von 30° entspricht.

Für jede Kombination aus Position $(x, y)$ und Orientierung $\theta$ wird das
rotierte Roboterpolygon auf Kollisionen mit Hindernissen und Umgebungsgrenzen geprüft.
Die Berechnung ist rechenintensiver als im 2D-Fall, da für jeden Gitterpunkt zwölf
Orientierungen evaluiert werden müssen. Das Ergebnis ist ein dreidimensionales
boolesches Array, das die Befahrbarkeit jeder Konfiguration angibt.

\subsubsection{Pfadplanungsalgorithmen}
Für die 3D-Pfadplanung wurden vier Algorithmen implementiert: A*, Dijkstra, \ac{RRT}
und \ac{PRM}. Die graphbasierten Verfahren A* und Dijkstra operieren auf dem 3D-Gitter
mit einer erweiterten Nachbarschaftsdefinition: Neben der 8-Nachbarschaft in der
xy-Ebene werden für jede Position drei Optionen für die Orientierung berücksichtigt
(unverändert, +30°, -30°).

Die samplingbasierten Verfahren \ac{RRT} und \ac{PRM} wurden für den dreidimensionalen
Raum $(x, y, \theta)$ angepasst. Bei der Bewegung zwischen zwei Konfigurationen wird
sowohl die räumliche Distanz als auch die Winkeländerung interpoliert und auf
Kollisionsfreiheit geprüft.

\subsubsection{Evaluation}
Die Evaluation wurde mit einem Startpunkt bei $(1, 1, 0°)$ und einem Zielpunkt
bei $(7, 2, 180°)$ durchgeführt. Diese Konfiguration erfordert nicht nur eine
räumliche Navigation durch die Hindernisse, sondern auch eine Drehung des
Roboters um 180°.

A* und Dijkstra fanden optimale Pfade mit einer Länge von 66,5 Metern bei
Rechenzeiten von 0,74 bzw. 0,68 Sekunden. \ac{RRT} benötigte mit 8,69 Sekunden
deutlich mehr Rechenzeit und lieferte einen längeren Pfad von 79,3 Metern.
\ac{PRM} erzielte mit 72,7 Metern und 0,22 Sekunden einen guten Kompromiss
zwischen Pfadqualität und Rechenzeit.

Obwohl samplingbasierte Verfahren theoretisch besser mit höheren Dimensionen
skalieren \parencite[S. 1]{petrovic2018motion}, zeigt sich dieser Vorteil
bei nur drei Dimensionen noch nicht deutlich.
Die graphbasierten Verfahren profitieren hier von der noch handhabbaren Gittergröße.
In strukturierten Umgebungen mit engen Korridoren haben samplingbasierte Verfahren
zudem Schwierigkeiten, da zufällige Samples selten die schmalen Durchgänge treffen
(siehe \cref{fig:cspace3d_comparison} und \cref{tab:results_3d} im Anhang).

\section{Fazit}
\subsection{Zielerreichung und Projektergebnisse}
Das primäre Projektziel, ein Softwaresystem zur kollisionsfreien Pfadplanung für
mobile Roboter in polygonbasierten Lagerumgebungen zu entwickeln, wurde vollständig
erreicht. Die implementierte Lösung ermöglicht die Berechnung von Pfaden sowohl
für omnidirektionale Roboter im 2D-Konfigurationsraum als auch für orientierungsabhängige
Roboter im 3D-Konfigurationsraum.

Die systematische Evaluation von fünf Algorithmen auf drei Testumgebungen mit
unterschiedlichen Robotergeometrien lieferte quantitative Erkenntnisse über die
Stärken und Schwächen der verschiedenen Ansätze. A* und Dijkstra erwiesen sich
als zuverlässige Verfahren für optimale Pfade, während Best-First-Search bei
Zeitkritikalität Vorteile bietet. Die samplingbasierten Verfahren \ac{RRT} und \ac{PRM}
zeigten ihre Eignung für komplexere Szenarien, offenbarten jedoch Schwächen in
Umgebungen mit engen Korridoren.

\subsection{Kritische Reflexion}
Die gewählte Diskretisierung des Konfigurationsraums stellt einen Kompromiss dar.
Eine feinere Auflösung würde präzisere Pfade ermöglichen, erhöht jedoch den
Speicherbedarf und die Rechenzeit erheblich. Besonders im 3D-Fall mit zwölf
Winkelschritten ist die Auflösung relativ grob, was zu suboptimalen Pfaden
führen kann.

Die Evaluation basiert auf einzelnen Durchläufen pro Konfiguration. Da RRT und
PRM auf Zufallszahlen basieren, können die Ergebnisse bei wiederholter Ausführung
variieren. Eine statistisch robustere Evaluation würde Mehrfachdurchläufe mit
Mittelwertbildung erfordern.

Die Testumgebungen sind statisch und repräsentieren idealisierte Lagerhallen.
Reale Einsatzszenarien umfassen dynamische Hindernisse, Unsicherheiten in der
Lokalisierung und Sensorrauschen, die in dieser Arbeit nicht berücksichtigt wurden.

\subsection{Verbesserungspotenziale und Optimierungsansätze}
Die Pfadqualität könnte durch Nachbearbeitung verbessert werden. Pfadglättungsalgorithmen
würden die kantigen Trajektorien der gitterbasierten Verfahren in fahrbare Kurven
umwandeln. Für die samplingbasierten Verfahren existieren Varianten wie RRT* und
PRM*, die asymptotisch optimale Pfade garantieren
\parencite[S. 1]{karaman2011sampling}.

Die Rechenzeit ließe sich durch adaptive Auflösung reduzieren. In freien Bereichen
genügt eine grobe Diskretisierung, während in der Nähe von Hindernissen eine
feinere Auflösung sinnvoll wäre. Hierarchische Ansätze könnten zunächst auf
grobem Gitter planen und nur relevante Bereiche verfeinern.

Eine Erweiterung auf höherdimensionale Konfigurationsräume wäre ebenfalls denkbar.
Roboterarme mit sechs oder mehr Freiheitsgraden erfordern entsprechend viele
Dimensionen. In solchen Szenarien würden die samplingbasierten Verfahren ihre
Stärken gegenüber gitterbasierten Methoden deutlicher ausspielen können.

Neben den implementierten Algorithmen existieren weitere Ansätze, die das System
ergänzen könnten. Die Potentialfeld-Methode modelliert das Ziel als anziehende
und Hindernisse als abstoßende Kräfte, wodurch der Roboter entlang des
Gradientenabstiegs zum Ziel navigiert. Trajektorienoptimierungsverfahren wie
CHOMP \parencite{ratliff2009chomp} oder TrajOpt \parencite{schulman2014trajopt} könnten 
die gefundenen Pfade hinsichtlich Glätte und Energieeffizienz nachoptimieren.

\subsection{Ausblick}
Für einen produktiven Einsatz des entwickelten Systems wären weitere Entwicklungsschritte
erforderlich. Die Integration mit realer Sensorik, insbesondere LIDAR und Kamerasystemen,
würde eine dynamische Aktualisierung der Umgebungskarte ermöglichen. Dadurch könnte
der Roboter auf unvorhergesehene Hindernisse reagieren und seine Pfade in Echtzeit
anpassen.

Ein weiterer wichtiger Aspekt ist die Koordination mehrerer Roboter in derselben
Umgebung. In modernen Lagerhäusern operieren häufig Flotten von \ac{AMR} gleichzeitig,
was eine kollisionsfreie Pfadplanung unter Berücksichtigung der anderen Roboter
erfordert. Hierfür existieren dezentrale und zentrale Ansätze, die auf den
implementierten Einzelroboter-Algorithmen aufbauen könnten.

Schließlich bieten maschinelle Lernverfahren vielversprechende Möglichkeiten zur
Beschleunigung der Pfadplanung. Neuronale Netze könnten trainiert werden, um
gute Initiallösungen für die Optimierung zu liefern oder die Heuristik von A*
zu verbessern. Solche hybriden Ansätze kombinieren die Zuverlässigkeit klassischer
Algorithmen mit der Effizienz datengetriebener Methoden.

\section*{Projektrepository}
\addcontentsline{toc}{section}{Projektrepository}
Der vollständige Quellcode ist im GitHub-Repository verfügbar: \url{https://github.com/svenb23/mobile-robotik-pfadplanung}

\newpage

\printbibliography
\addcontentsline{toc}{section}{Literaturverzeichnis}

\newpage
\section*{Verzeichnis der Anhänge}
\addcontentsline{toc}{section}{Verzeichnis der Anhänge}

\appendix
\section*{Anhang}
\addcontentsline{toc}{section}{Anhang}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/maps_overview.png}
    \caption{Übersicht der drei Testumgebungen: easy (links), medium (Mitte), hard (rechts)}
    \label{fig:maps_overview}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../figures/robot_geometries.png}
    \caption{Die drei Robotergeometrien: Kreis (links), Rechteck (Mitte), Dreieck (rechts)}
    \label{fig:robot_geometries}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/cspace_comparison.png}
    \caption{Konfigurationsräume für verschiedene Robotergeometrien: Die grauen Bereiche zeigen die erweiterten Hindernisse}
    \label{fig:cspace_comparison}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/algorithm_comparison.png}
    \caption{Vergleich der Pfadplanungsalgorithmen: Unterschiedliche Strategien führen zu verschiedenen Pfadverläufen}
    \label{fig:algorithm_comparison}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/comparison_hard.png}
    \caption{Evaluationsergebnisse in der \textit{hard}-Umgebung: PRM scheitert bei rechteckiger und dreieckiger Robotergeometrie (rechte Spalte, mittlere und untere Zeile)}
    \label{fig:comparison_hard}
\end{figure}

\begin{table}[H]
\centering
\caption{Evaluationsergebnisse der 2D-Pfadplanung (kreisförmiger Roboter)}
\label{tab:results_2d}
\begin{tabular}{llrrr}
\toprule
Umgebung & Algorithmus & Pfadlänge [m] & Wegpunkte & Zeit [s] \\
\midrule
easy & A* & 23,65 & 67 & 0,010 \\
easy & Dijkstra & 23,65 & 67 & 0,017 \\
easy & Best-First & 24,60 & 71 & 0,004 \\
easy & RRT & 28,18 & 58 & 0,018 \\
easy & PRM & 23,31 & 21 & 0,106 \\
\midrule
medium & A* & 41,72 & 121 & 0,020 \\
medium & Dijkstra & 41,72 & 121 & 0,019 \\
medium & Best-First & 50,69 & 148 & 0,010 \\
medium & RRT & 51,00 & 104 & 0,125 \\
medium & PRM & 45,88 & 25 & 0,067 \\
\midrule
hard & A* & 53,12 & 164 & 0,022 \\
hard & Dijkstra & 53,12 & 164 & 0,023 \\
hard & Best-First & 58,80 & 185 & 0,012 \\
hard & RRT & 62,02 & 126 & 0,414 \\
hard & PRM & 55,04 & 22 & 0,045 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../figures/cspace3d_comparison.png}
    \caption{3D-Konfigurationsraum mit Pfaden der vier Algorithmen: Die Hindernisse erstrecken sich als vertikale Wände durch alle Orientierungen}
    \label{fig:cspace3d_comparison}
\end{figure}

\begin{table}[H]
\centering
\caption{Evaluationsergebnisse der 3D-Pfadplanung (rechteckiger Roboter, \textit{hard}-Umgebung)}
\label{tab:results_3d}
\begin{tabular}{lrrr}
\toprule
Algorithmus & Pfadlänge [m] & Wegpunkte & Zeit [s] \\
\midrule
A* & 66,50 & -- & 0,74 \\
Dijkstra & 66,50 & -- & 0,68 \\
RRT & 79,30 & -- & 8,69 \\
PRM & 72,70 & -- & 0,22 \\
\bottomrule
\end{tabular}
\end{table}

\newpage
\section*{Quellcode}
\addcontentsline{toc}{section}{Quellcode}

\subsection*{robot.py -- Robotergeometrie}
\begin{lstlisting}[language=Python]
import numpy as np
from shapely.geometry import Polygon
from typing import List, Tuple

class Robot:
    """Robot geometry defined by polygon vertices centered at origin."""

    def __init__(self, vertices: List[Tuple[float, float]]):
        self.vertices = vertices
        self.polygon = Polygon(vertices)

    def at(self, x: float, y: float, theta: float = 0) -> Polygon:
        """Return robot polygon at position (x,y) with rotation theta."""
        if theta == 0:
            transformed = [(vx + x, vy + y) for vx, vy in self.vertices]
        else:
            cos_t, sin_t = np.cos(theta), np.sin(theta)
            transformed = [
                (vx * cos_t - vy * sin_t + x, vx * sin_t + vy * cos_t + y)
                for vx, vy in self.vertices
            ]
        return Polygon(transformed)

    @classmethod
    def rectangle(cls, width: float, height: float) -> 'Robot':
        w, h = width / 2, height / 2
        return cls([(-w, -h), (w, -h), (w, h), (-w, h)])

    @classmethod
    def circle(cls, radius: float, n_points: int = 16) -> 'Robot':
        angles = np.linspace(0, 2 * np.pi, n_points, endpoint=False)
        vertices = [(radius * np.cos(a), radius * np.sin(a)) for a in angles]
        return cls(vertices)

    @classmethod
    def triangle(cls, base: float, height: float) -> 'Robot':
        return cls([
            (height / 2, 0),
            (-height / 2, -base / 2),
            (-height / 2, base / 2),
        ])
\end{lstlisting}

\subsection*{warehouse.py -- Lagerumgebung}
\begin{lstlisting}[language=Python]
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon as MplPolygon
from shapely.geometry import Polygon, Point
from typing import List, Tuple

class Warehouse:
    """Warehouse environment with polygon obstacles."""

    def __init__(self, width: float, height: float):
        self.width = width
        self.height = height
        self.obstacles: List[Tuple[Polygon, List, str]] = []

    def add(self, vertices: List[Tuple[float, float]], name: str = "") -> None:
        polygon = Polygon(vertices)
        self.obstacles.append((polygon, vertices, name))

    def is_free(self, point: Tuple[float, float]) -> bool:
        x, y = point
        if not (0 < x < self.width and 0 < y < self.height):
            return False
        for polygon, _, _ in self.obstacles:
            if polygon.contains(Point(point)):
                return False
        return True

    def get_polygons(self) -> List[Polygon]:
        return [polygon for polygon, _, _ in self.obstacles]
\end{lstlisting}

\subsection*{cspace.py -- 2D-Konfigurationsraum}
\begin{lstlisting}[language=Python]
import numpy as np
from shapely.geometry import Polygon
from typing import Tuple

class CSpace:
    """2D Configuration space (x, y) for omnidirectional robots."""

    def __init__(self, warehouse, robot, resolution: float = 0.5):
        self.warehouse = warehouse
        self.robot = robot
        self.resolution = resolution
        self.cols = int(warehouse.width / resolution)
        self.rows = int(warehouse.height / resolution)
        self.grid = np.zeros((self.rows, self.cols), dtype=bool)
        self._compute()

    def _compute(self):
        obstacles = self.warehouse.get_polygons()
        for row in range(self.rows):
            for col in range(self.cols):
                x = (col + 0.5) * self.resolution
                y = (row + 0.5) * self.resolution
                robot_poly = self.robot.at(x, y)
                if not self._inside_bounds(robot_poly):
                    self.grid[row, col] = True
                    continue
                for obs in obstacles:
                    if robot_poly.intersects(obs):
                        self.grid[row, col] = True
                        break

    def _inside_bounds(self, polygon: Polygon) -> bool:
        minx, miny, maxx, maxy = polygon.bounds
        return minx >= 0 and miny >= 0 and \
               maxx <= self.warehouse.width and maxy <= self.warehouse.height

    def is_free(self, x: float, y: float) -> bool:
        col = int(x / self.resolution)
        row = int(y / self.resolution)
        if 0 <= row < self.rows and 0 <= col < self.cols:
            return not self.grid[row, col]
        return False
\end{lstlisting}

\subsection*{pathfinder.py -- Pfadplanungsalgorithmen (Auszug)}
\begin{lstlisting}[language=Python]
import numpy as np
from pathfinding.core.grid import Grid
from pathfinding.core.diagonal_movement import DiagonalMovement
from pathfinding.finder.a_star import AStarFinder
from pathfinding.finder.dijkstra import DijkstraFinder
from pathfinding.finder.best_first import BestFirst
from typing import List, Tuple, Optional
import random

class Pathfinder:
    """2D Pathfinding on CSpace grid with multiple algorithms."""

    def __init__(self, cspace, algorithm: str = "a_star"):
        self.cspace = cspace
        self.algorithm = algorithm
        self._init_finder()

    def _find_rrt(self, start, goal, max_iter=5000, step_size=0.5):
        """RRT (Rapidly-exploring Random Tree) algorithm."""
        tree = {start: None}
        for _ in range(max_iter):
            if random.random() < 0.1:
                sample = goal
            else:
                sample = (random.uniform(0, self.cspace.warehouse.width),
                          random.uniform(0, self.cspace.warehouse.height))
            nearest = min(tree.keys(), key=lambda n: self._dist(n, sample))
            direction = np.array(sample) - np.array(nearest)
            dist = np.linalg.norm(direction)
            if dist < 1e-6:
                continue
            direction = direction / dist
            new_point = tuple(np.array(nearest) + direction * min(step_size, dist))
            if self._line_free(nearest, new_point):
                tree[new_point] = nearest
                if self._dist(new_point, goal) < step_size and \
                   self._line_free(new_point, goal):
                    tree[goal] = new_point
                    return self._reconstruct_path(tree, goal)
        return None

    def _find_prm(self, start, goal, n_samples=500, k_neighbors=10):
        """PRM (Probabilistic Roadmap) algorithm."""
        samples = [start, goal]
        for _ in range(n_samples):
            point = (random.uniform(0, self.cspace.warehouse.width),
                     random.uniform(0, self.cspace.warehouse.height))
            if self.cspace.is_free(point[0], point[1]):
                samples.append(point)
        edges = {s: [] for s in samples}
        for s in samples:
            neighbors = sorted(samples, key=lambda n: self._dist(s, n))[1:k_neighbors+1]
            for n in neighbors:
                if self._line_free(s, n):
                    edges[s].append(n)
                    edges[n].append(s)
        return self._astar_roadmap(start, goal, edges)
\end{lstlisting}

\subsection*{cspace3d.py -- 3D-Konfigurationsraum}
\begin{lstlisting}[language=Python]
import numpy as np
from shapely.geometry import Polygon
from typing import Tuple

class CSpace3D:
    """3D Configuration space (x, y, theta) for non-holonomic robots."""

    def __init__(self, warehouse, robot, resolution: float = 0.5, n_angles: int = 12):
        self.warehouse = warehouse
        self.robot = robot
        self.resolution = resolution
        self.n_angles = n_angles
        self.angle_resolution = 2 * np.pi / n_angles
        self.cols = int(warehouse.width / resolution)
        self.rows = int(warehouse.height / resolution)
        self.grid = np.zeros((self.rows, self.cols, n_angles), dtype=bool)
        self._compute()

    def _compute(self):
        obstacles = self.warehouse.get_polygons()
        angles = np.linspace(0, 2 * np.pi, self.n_angles, endpoint=False)
        for row in range(self.rows):
            for col in range(self.cols):
                x = (col + 0.5) * self.resolution
                y = (row + 0.5) * self.resolution
                for k, theta in enumerate(angles):
                    robot_poly = self.robot.at(x, y, theta)
                    if not self._inside_bounds(robot_poly):
                        self.grid[row, col, k] = True
                        continue
                    for obs in obstacles:
                        if robot_poly.intersects(obs):
                            self.grid[row, col, k] = True
                            break

    def is_free(self, x: float, y: float, theta: float) -> bool:
        col = int(x / self.resolution)
        row = int(y / self.resolution)
        k = int((theta % (2 * np.pi)) / self.angle_resolution) % self.n_angles
        if 0 <= row < self.rows and 0 <= col < self.cols:
            return not self.grid[row, col, k]
        return False
\end{lstlisting}

\subsection*{pathfinder3d.py -- A* für 3D-Konfigurationsraum}
\begin{lstlisting}[language=Python]
import numpy as np
from typing import List, Tuple, Optional
import heapq

class Pathfinder3D:
    """A* pathfinding in 3D configuration space."""

    def __init__(self, cspace3d):
        self.cspace = cspace3d

    def find(self, start, goal) -> Optional[List[Tuple[float, float, float]]]:
        start_cell = self.cspace.to_grid(*start)
        goal_cell = self.cspace.to_grid(*goal)
        if self.cspace.grid[start_cell] or self.cspace.grid[goal_cell]:
            return None
        open_set = [(0, start_cell)]
        came_from = {}
        g_score = {start_cell: 0}
        neighbors_xy = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1),(0,0)]
        neighbors_theta = [-1, 0, 1]

        while open_set:
            _, current = heapq.heappop(open_set)
            if current == goal_cell:
                path = [current]
                while current in came_from:
                    current = came_from[current]
                    path.append(current)
                return [self.cspace.to_world(*cell) for cell in path[::-1]]
            row, col, k = current
            for dr, dc in neighbors_xy:
                for dk in neighbors_theta:
                    if dr == 0 and dc == 0 and dk == 0:
                        continue
                    nr, nc = row + dr, col + dc
                    nk = (k + dk) % self.cspace.n_angles
                    if not (0 <= nr < self.cspace.rows and 0 <= nc < self.cspace.cols):
                        continue
                    if self.cspace.grid[nr, nc, nk]:
                        continue
                    neighbor = (nr, nc, nk)
                    spatial_dist = np.sqrt(dr**2 + dc**2) * self.cspace.resolution
                    rotation_cost = abs(dk) * self.cspace.angle_resolution * 0.5
                    tentative_g = g_score[current] + spatial_dist + rotation_cost
                    if neighbor not in g_score or tentative_g < g_score[neighbor]:
                        came_from[neighbor] = current
                        g_score[neighbor] = tentative_g
                        h = np.sqrt((nr-goal_cell[0])**2 + (nc-goal_cell[1])**2) * \
                            self.cspace.resolution
                        heapq.heappush(open_set, (tentative_g + h, neighbor))
        return None
\end{lstlisting}

\subsection*{pathfinder3d\_dijkstra.py -- Dijkstra für 3D-Konfigurationsraum}
\begin{lstlisting}[language=Python]
import numpy as np
from typing import List, Tuple, Optional
import heapq

class Pathfinder3D_Dijkstra:
    """Dijkstra pathfinding in 3D configuration space."""

    def __init__(self, cspace3d):
        self.cspace = cspace3d

    def find(self, start: Tuple[float, float, float],
             goal: Tuple[float, float, float]) -> Optional[List[Tuple[float, float, float]]]:
        """Find optimal path from start to goal using Dijkstra (no heuristic)."""
        start_cell = self.cspace.to_grid(*start)
        goal_cell = self.cspace.to_grid(*goal)

        if self.cspace.grid[start_cell] or self.cspace.grid[goal_cell]:
            return None

        open_set = [(0, start_cell)]
        came_from = {}
        g_score = {start_cell: 0}

        # 8-connectivity in xy + 3 options for theta
        neighbors_xy = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1), (0, 0)]
        neighbors_theta = [-1, 0, 1]

        while open_set:
            current_g, current = heapq.heappop(open_set)

            if current == goal_cell:
                # Reconstruct path
                path = [current]
                while current in came_from:
                    current = came_from[current]
                    path.append(current)
                return [self.cspace.to_world(*cell) for cell in path[::-1]]

            if current_g > g_score.get(current, float('inf')):
                continue

            row, col, k = current

            for dr, dc in neighbors_xy:
                for dk in neighbors_theta:
                    if dr == 0 and dc == 0 and dk == 0:
                        continue

                    nr = row + dr
                    nc = col + dc
                    nk = (k + dk) % self.cspace.n_angles

                    if not (0 <= nr < self.cspace.rows and 0 <= nc < self.cspace.cols):
                        continue
                    if self.cspace.grid[nr, nc, nk]:
                        continue

                    neighbor = (nr, nc, nk)
                    # Cost = spatial distance + rotation cost
                    spatial_dist = np.sqrt(dr**2 + dc**2) * self.cspace.resolution
                    rotation_cost = abs(dk) * self.cspace.angle_resolution * 0.5
                    tentative_g = g_score[current] + spatial_dist + rotation_cost

                    if neighbor not in g_score or tentative_g < g_score[neighbor]:
                        came_from[neighbor] = current
                        g_score[neighbor] = tentative_g
                        heapq.heappush(open_set, (tentative_g, neighbor))

        return None
\end{lstlisting}

\subsection*{pathfinder3d\_rrt.py -- RRT für 3D-Konfigurationsraum}
\begin{lstlisting}[language=Python]
import numpy as np
from typing import List, Tuple, Optional
import random

class Pathfinder3D_RRT:
    """RRT (Rapidly-exploring Random Tree) in 3D configuration space."""

    def __init__(self, cspace3d):
        self.cspace = cspace3d

    def find(self, start: Tuple[float, float, float],
             goal: Tuple[float, float, float],
             max_iter: int = 10000, step_size: float = 0.5,
             angle_step: float = 0.3) -> Optional[List[Tuple[float, float, float]]]:
        """Find path using RRT algorithm."""
        tree = {start: None}

        for _ in range(max_iter):
            # Sample random point (10% bias towards goal)
            if random.random() < 0.1:
                sample = goal
            else:
                sample = (
                    random.uniform(0, self.cspace.warehouse.width),
                    random.uniform(0, self.cspace.warehouse.height),
                    random.uniform(0, 2 * np.pi)
                )

            # Find nearest node in tree
            nearest = min(tree.keys(), key=lambda n: self._dist(n, sample))

            # Steer towards sample
            direction = np.array(sample[:2]) - np.array(nearest[:2])
            dist = np.linalg.norm(direction)
            if dist < 1e-6:
                new_x, new_y = nearest[0], nearest[1]
            else:
                direction = direction / dist
                new_pos = np.array(nearest[:2]) + direction * min(step_size, dist)
                new_x, new_y = new_pos[0], new_pos[1]

            # Interpolate angle
            angle_diff = sample[2] - nearest[2]
            angle_diff = (angle_diff + np.pi) % (2 * np.pi) - np.pi
            new_theta = nearest[2] + np.sign(angle_diff) * min(abs(angle_diff), angle_step)
            new_theta = new_theta % (2 * np.pi)

            new_point = (new_x, new_y, new_theta)

            # Add to tree if path is collision-free
            if self._line_free(nearest, new_point):
                tree[new_point] = nearest

                # Check if goal is reachable
                if self._dist(new_point, goal) < step_size:
                    if self._line_free(new_point, goal):
                        tree[goal] = new_point
                        return self._reconstruct(tree, goal)

        return None

    def _dist(self, a, b):
        """Distance metric combining spatial and angular distance."""
        spatial = np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)
        angle_diff = abs(a[2] - b[2])
        angle_diff = min(angle_diff, 2 * np.pi - angle_diff)
        return spatial + angle_diff * 0.5

    def _line_free(self, a, b, steps: int = 10):
        """Check if straight line between two configurations is collision-free."""
        for i in range(steps + 1):
            t = i / steps
            x = a[0] + t * (b[0] - a[0])
            y = a[1] + t * (b[1] - a[1])
            angle_diff = b[2] - a[2]
            angle_diff = (angle_diff + np.pi) % (2 * np.pi) - np.pi
            theta = (a[2] + t * angle_diff) % (2 * np.pi)
            if not self.cspace.is_free(x, y, theta):
                return False
        return True

    def _reconstruct(self, tree, goal):
        """Reconstruct path from tree."""
        path = [goal]
        current = goal
        while tree[current] is not None:
            current = tree[current]
            path.append(current)
        return path[::-1]
\end{lstlisting}

\subsection*{pathfinder3d\_prm.py -- PRM für 3D-Konfigurationsraum}
\begin{lstlisting}[language=Python]
import numpy as np
from typing import List, Tuple, Optional
import random
import heapq

class Pathfinder3D_PRM:
    """PRM (Probabilistic Roadmap) in 3D configuration space."""

    def __init__(self, cspace3d):
        self.cspace = cspace3d

    def find(self, start: Tuple[float, float, float],
             goal: Tuple[float, float, float],
             n_samples: int = 1000, k_neighbors: int = 15) -> Optional[List[Tuple[float, float, float]]]:
        """Find path using PRM algorithm."""
        # Sample random collision-free configurations
        samples = [start, goal]
        for _ in range(n_samples):
            point = (
                random.uniform(0, self.cspace.warehouse.width),
                random.uniform(0, self.cspace.warehouse.height),
                random.uniform(0, 2 * np.pi)
            )
            if self.cspace.is_free(*point):
                samples.append(point)

        # Build roadmap by connecting k-nearest neighbors
        edges = {s: [] for s in samples}
        for s in samples:
            neighbors = sorted(samples, key=lambda n: self._dist(s, n))[1:k_neighbors+1]
            for n in neighbors:
                if self._line_free(s, n):
                    edges[s].append(n)
                    edges[n].append(s)

        # Search roadmap using A*
        return self._astar(start, goal, edges)

    def _astar(self, start, goal, edges):
        """A* search on the roadmap."""
        open_set = [(0, start)]
        came_from = {}
        g_score = {start: 0}

        while open_set:
            _, current = heapq.heappop(open_set)

            if current == goal:
                path = [current]
                while current in came_from:
                    current = came_from[current]
                    path.append(current)
                return path[::-1]

            for neighbor in edges.get(current, []):
                tentative_g = g_score[current] + self._dist(current, neighbor)
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f = tentative_g + self._dist(neighbor, goal)
                    heapq.heappush(open_set, (f, neighbor))

        return None

    def _dist(self, a, b):
        """Distance metric combining spatial and angular distance."""
        spatial = np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)
        angle_diff = abs(a[2] - b[2])
        angle_diff = min(angle_diff, 2 * np.pi - angle_diff)
        return spatial + angle_diff * 0.5

    def _line_free(self, a, b, steps: int = 10):
        """Check if straight line between two configurations is collision-free."""
        for i in range(steps + 1):
            t = i / steps
            x = a[0] + t * (b[0] - a[0])
            y = a[1] + t * (b[1] - a[1])
            angle_diff = b[2] - a[2]
            angle_diff = (angle_diff + np.pi) % (2 * np.pi) - np.pi
            theta = (a[2] + t * angle_diff) % (2 * np.pi)
            if not self.cspace.is_free(x, y, theta):
                return False
        return True
\end{lstlisting}

\subsection*{maps.py -- Kartendefinitionen}
\begin{lstlisting}[language=Python]
MAPS = {
    "easy": {
        "width": 20,
        "height": 15,
        "obstacles": [
            [(3, 3), (7, 3), (7, 5), (3, 5)],
            [(12, 8), (16, 8), (16, 11), (12, 11)],
        ]
    },

    "medium": {
        "width": 25,
        "height": 20,
        "obstacles": [
            [(4, 0), (6, 0), (6, 12), (4, 12)],
            [(4, 16), (6, 16), (6, 20), (4, 20)],
            [(10, 8), (12, 8), (12, 20), (10, 20)],
            [(16, 0), (18, 0), (18, 14), (16, 14)],
            [(8, 3), (14, 3), (14, 5), (8, 5)],
            [(18, 10), (23, 10), (23, 12), (18, 12)],
        ]
    },

    "hard": {
        "width": 30,
        "height": 25,
        "obstacles": [
            [(3, 0), (5, 0), (5, 18), (3, 18)],
            [(3, 18), (12, 18), (12, 20), (3, 20)],
            [(8, 5), (10, 5), (10, 15), (8, 15)],
            [(10, 5), (18, 5), (18, 7), (10, 7)],
            [(13, 10), (15, 10), (15, 20), (13, 20)],
            [(15, 12), (22, 12), (22, 14), (15, 14)],
            [(20, 0), (22, 0), (22, 10), (20, 10)],
            [(20, 16), (22, 16), (22, 25), (20, 25)],
            [(24, 5), (28, 5), (28, 7), (24, 7)],
            [(24, 7), (26, 7), (26, 25), (24, 25)],
            [(12, 0), (14, 0), (14, 3), (12, 3)],
            [(5, 8), (7, 8), (7, 12), (5, 12)],
            [(5, 12), (8, 12), (8, 14), (5, 14)],
            [(26, 20), (30, 20), (30, 22), (26, 22)],
        ]
    },
}
\end{lstlisting}

\end{document}
